# 零碎的知识点
- 当class内至少含有一个virtual函数，才能将它声明为virtual析构函数
- 当class中有虚函数，会有一个vptr（virtual table pointer）指针，来在运行时决定
哪一个虚函数该被调用，占用一个指针的大小
- 纯虚函数是虚函数的一个子集，用于抽象类，含有纯虚函数的类就是抽象类，它不能生成对象
- static关键字总结
    - 隐藏：可以在不同的文件中定义同名函数和同名变量
    - 保持变量的内容的持久：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围。
    如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。
    - 默认初始化为0：在静态数据区，内存中所有的字节默认值都是0x00
    - 类成员声明为static：静态数据成员是类的成员，而不是对象的成员
        1. 类的静态成员函数**仅能访问类的静态数据和静态成员函数** 
        2. 不能将静态成员函数定义为虚函数
        3. 类的静态成员初始化**在类体外进行**，而前面不加static
        4. 为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响
- 内存分区
    - 堆区：由编程人员手动申请，手动释放。使用malloc或者new进行堆的申请，堆的总大小为机器的虚拟内存的大小。
    - 栈区：由系统进行内存的管理。主要存放**函数的参数以及局部变量**。在函数完成执行，系统自行释放栈区内存，不需要用户管理。
    - 全局/静态存储区：全局/静态存储区内的变量在程序编译阶段**已经分配好内存空间并初始化**。分为全局初始化区和BSS区（全局未初始化区）。
    这块内存在程序的整个运行期间都存在，它主要存放**静态变量、全局变量**。
    - 文字常量区：常量字符串存放在这里
    - 代码区：存放程序编译后的二进制代码，不可寻址区。
- new和malloc的区别
    - new先底层调用malloc分了配内存，然后创建一个对象（调用构造函数），delete先调用析构函数（清理资源），然后底层调用free释放空间
    - malloc是C语言中的**库函数**，而new是C++中的**操作符**。
    - malloc申请之后返回的类型是void*，而new返回的指针带有类型。
    - malloc只负责内存的分配而不会调用类的构造函数，而new不仅会分配内存，而且会自动调用类的构造函数，并且可以自动计算所需要大小。
- 堆区和栈区的区别：
    - 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制
    - 空间大小：默认的栈空间大小是1M，32位堆内存可以达到4G的空间
    - 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列
    - 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
    - 生长方式和效率
- const的作用
    - 定义常量
    - 便于类型检查
    - 保护防止修改
    - 方便进行参数调整和修改
    - 节约空间
- const的使用
    - 定义常量必须初始化（修饰变量）
    - 顶层和底层const（修饰指针引用）
    - const修饰函数参数：参数为引用，可以增加效率同时防止更改。按值传递会先建立一个类对象的副本，而传地址更有效。
    - const修饰函数返回值，多同于操作符重载。
    - 类相关const：
        1. const修饰成员变量，只能在初始化列表中赋值
        2. 修饰成员函数，被const类对象，指针，引用调用。
        3. const可以防止对成员函数的修改，也可以被非const对象调用
- 采用const_cast把const转化为非const。
- 正则表达式 regexp(后面跟着字符串)：
    - .(点)：匹配任意字符；
    - |(or)：两者之一；
    - []:[2345]56表示256，356，456，556其中一种，^表示否定[^123]；
    - 匹配范围：[1-5],[a-f];
    - 特殊字符：使用转义(\\)
    - 匹配多个实例
        1. *：0个或多个匹配；
        2. +：1个或多个匹配{1,}；
        3. ?：0个或一个匹配{0,1}；
        4. {n}：指定数量的匹配；
        5. {n,}：不少于指定数量的匹配；
        6. {n,m}：范围匹配(m不超过255)。
    - 定位符
        1. 
- Linux文件三个时间：
    - mtime：修改时间
    - ctime：状态时间，更改了权限和属性，就会更新时间
    - atime：访问时间
- 枚举变量的默认值是前一个变量加1，而第一个没有被赋值，其默认值是0。
- float，bool，int，指针变量与“零值”的比较
    - bool：if(!n)
    - int：if(n == 0)
    - float：**const float ep = 0.0000001;  if((x >= -ep)&&(x <= ep))**
    - 指针：if(p == NULL)
- 字节对齐：便于cpu快速访问，合理利用字节对齐可以节省空间。
- 指针和引用的区别
    - 指针是一个变量（对象），引用是变量的别名
    - 引用必须初始化且不能更改，指针可以为空，并且可以更改
    - 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 
    用的修改都会改变引用所指向的对象
    - 可以有const指针，但是没有const引用
    - 指针和引用的自增（++）运算意义不一样
    - 指针可以有多级，引用只能有一级
- 值传递和引用传递
    - 值传递过程中，被调函数的形参作为被调函数的局部变量来处理，成为实参的一个副本，被调函数的任何操作都是
    作为局部变量进行，不会影响实参变量的值、
    - 引用传递是传递实参变量的地址，因此被调函数对形参的任何参作都被处理成间接寻址。
- 指针和数组
    - 修改内容不同：char a[] = "hello";可以通过取下标的方式对元素值进行修改。
    char *p = "hello";p指向常量字符串，不可以改变其中的值
    - sizeof不同
- 指针与数字相加，主要是计算偏移量，大小=数字*sizeof(指针指向的类型)
- sizeof和strlen的区别
    - sizeof是**关键字**，也是**运算符**。strlen是函数
    - sizeof返回结果是size_t
    - sizeof是在编译时计算的，可以用来定义数组的维度。
- 野指针和空指针
    - 野指针是指向不可用内存的指针。指针在创建时，其值是随机的，指针在free和delete后，也会导致野指针
    - 空指针：可以指向任何其他类型的指针。C++11中用nullptr来定义空指针
- <>and""的区别
    - <>编译器先从标准库的路径搜索，使用系统文件调用较快。
    - ""是从用户的工作目录开始搜索，然后去寻找系统路径，使自定义文件较快。
- #define有什么缺陷
    - 无法进行类型检查
    - 由于优先级不同，可能存在副作用
    - 无法操作类的私有成员
- typedef和define的区别
    - 原理不同：define是预处理指令，不做类型检查；typedef是关键字，在自己的作用域给一个已经存在的类型起别名
    - 功能不同：typedef不止包括内部类型，还有自定义类型struct。
    - define没有作用域限制
    - define只是简单的字符串的替换，而typedef是类型别名带有实际意义
- const和define的区别
    - define预处理阶段进行替换，const是在编译阶段进行类型检查
    - define不分配内存，在内存中有多个拷贝，消耗内存大；const在静态区分配内存，只有一个拷贝
    - define没有类型检查，const有
- struct和union区别
    - 联合体所有成员共用一块地址空间，长度等于最长成员的长度；结构体占用空间是累加的
    - 对于联合体不同成员赋值，将会对其他成员重写；结构体没有影响
- C和C++区别
    - c面向过程，c++面向对象
    - 动态内存的管理方式不一样
    - c和c++中的struct不同
        1. c的struct不能有函数成员，c++可以
        2. c的struct没有权限的限定
        3. c的struct不能继承
    - c不支持函数的重载
    - c++有引用，c没有
    - 输入输出流不同
- c++中struct和class区别
    - 默认的继承访问权限。struct是public的，class是private的
- 公有，私有，保护继承
    - 基类中私有成员private在派生类三个继承均不可访问
    - 公有：public->public,protected->protected
    - 私有：public->private,protected->private
    - 保护：public->protected,protected->protected
- 2乘以8的最有效的方法
    - 2<<3:左移表示乘法
    - (x<<3)-1:x的7倍
- **select，poll，epoll之间区别**
    - select:
- 进程与线程的区别
    - 进程是系统进行分配资源和调度的独立单位。是资源分配的基本单位
    - 线程是进程的实体，是CPU调度和分配的基本单位
    - 一个线程只能属于一个进程，一个进程可以包含多个线程
    - 属于一个进程的所有线程共享资源，进程间相互独立，有各自的内存空间
    - 进程是程序的一次执行，线程是一段程序片段的执行
- 一个进程可以创建多少线程，和什么有关
    - 主要由用户可用的内存空间和栈的大小来决定，比如x86平台32位系统，寻址空间为4GB(2^32-1),用户可以使用的
    大小大约为2GB，每个栈的大小默认为1MB，大约可以创建2000个进程
- 一个程序从开始运行到结束的完整过程
    - 预处理阶段
        1. 宏定义指令
        2. 条件编译指令
        3. 头文件包含指令
    - 编译阶段：把预编译的文件进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件
    - 汇编阶段：主要的作用是汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程
    - 链接阶段：链接程序的主要工作就是将有关的目标文件彼此相连接。
- 进程间通信方式总结（windows 和linux）
    - windows：
         1. 文件映射
         2. 共享内存
         3. 匿名管道（父子进程）
         4. 命名管道（不相关的进程）
         5. 邮件槽
         6. 剪切板
         7. 动态数据交换
         8. sockets
    - linux：
         1. 管道
         2. 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。
         3. 共享内存：由一个进程创建，但多个进程都可以访问。
         4. 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
         5. 套接字sockets：它可用于不同及其间的进程通信
         6. 信号： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生  
- 线程间通信方式
    - 互斥量
    - 临界区
    - 信号量
    - 事件
- 进程调度
    - 先进先出
    - 最短CPU运行期优先调度算法
    - 时间片轮换法
    - 多级反馈队列
- OSI的7层模型
    - 物理层
    - 数据链路层：
    - 网络层：路径选择、路由及逻辑寻址
    - 传输层：将上层数据分段并提供端到端的、可靠的或不可靠的传输
    - 会话层：负责建立、管理、终止进程之间的会话
    - 表示层：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解
    - 应用层：为操作系统或网络应用程序提供访问网络服务的接口
- linux命令
    - df查看磁盘空间大小
    - top任务管理器
    - ps查看进程
- C++与java的区别
    - java运行在JVM上。可移植性强
    - java取消指针，完全面向对象
    - Java编写效率高，但运行速度慢
    - 垃圾回收机制不同，java自动回收，c++析构函数
    - java在web应用强于c++，c++桌面应用强于java
- STL中的内存分配器:allocator:第一级小于128byte
    - 通过组织16个空闲列表，对小对象的分配做了优化
    - 小对象的快速分配和释放
    - 避免内存碎片的产生。零乱的内存碎片不仅会浪费内存空间
- hash表构造函数方法
    - 除法散列法：h(k) = k % p;
    - 平方散列法：
    - 斐波那契散列法：
- hash处理冲突的方法
    - 再散列法：Hi = (H(key) + di) % m
        1. 线性探测再散列
        2. 二次探测再散列 di = 1^2, -1^2, 2^2...
        3. 伪随机探测再散列
    - 再哈希法：同时构造多个哈希函数
    - 拉链法(链地址法)：将所有哈希地址为i的元素构成一个称为同义词链的单链表
- 海量数据
    - 海量日志数据：
        1. IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理
        2. 按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中
        3. 对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map
        4. 可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP
    - 搜索引擎记录top10
        1. 先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计
        2. 借助堆这个数据结构，找出Top K，时间复杂度为N*logK
- 红黑树的特征：红黑树，插入，删除，查找的复杂度都是O（log N）
    - 节点是红色或黑色。
    - 根节点是黑色
    - 每个叶节点是黑色的
    - 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
    - 从**任一节点到其每个叶子的**所有路径都包含相同数目的黑色节点
- AVL树：插入操作LL、LR、RR、RL
    - 左子树和右子树都是AVL树
    - 左子树和右子树的高度差不能超过1
- 红黑树应用
    - map和set都是用红黑树实现的
    - 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块
    - epoll在内核中的实现，用红黑树管理事件块
- STL中hash_map和map的区别
    - map
        1. 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。
        2. 红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现
        3. 适用处：对于那些有顺序要求的问题，用map会更高效一些
    - hash_map
        1. 因为内部实现了哈希表，因此其查找速度非常的快
        2. 缺点： 哈希表的建立比较耗费时间, 内存占的比较大
        3. 对于查找问题，unordered_map会更加高效一些
- STL vector的内部实现原理及基本用法
    - 一个动态增长的数组，里面有一个指针指向一片连续的内存空间，当空间装不下的时候会自动申请一片更大的空间。
    - reserve（Count） 函数主要是预留Count大小的空间，对应的是容器的容量，只有当空间不足时，才会操作，即重新分配一块内存，将原有元素拷贝到新内存，并销毁原有内存
    - resize（Count） 函数主要是用于改变size的，也就是改变vector的大小，最终改变的是（_Mylast - _Myfirst）的值，当size < Count时,就插入元素，当size >Count时，就擦除元素。
- fork函数
    - 计算机程序设计中的分叉函数。返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程标记；否则，出错返回-1。
    - 当调用fork()函数时，在该位置进程一分为二，一个是父进程，一个是子进程。
- vector注意事项
    - vector迭代器失效：使用者在一个较小索引位置上安插或移除元素。由于容量变化而引起重新分配。
- 重写与重载的区别
    - 方法的重写是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系
    - 重写要求参数列表相同；重载要求参数列表不同
    - 重写关系中，调用那个方法体，是根据**对象的类型**来决定；重载关系，是根据调用时的**实参表与形参表来**选择方法体的。
- 虚函数实现原理
    - 通过一张虚函数表来实现的
    - 通过虚函数指针指向虚函数表
    - 一般继承（无虚函数覆盖）
        1. 虚函数按照其声明顺序放于表中
        2. 父类的虚函数在子类的虚函数前面
    - 一般继承（有虚函数覆盖）
        1. 覆盖的函数被放到了虚表中原来父类虚函数的位置
        2. 没有被覆盖的函数依旧
- 析构函数为什么要写成虚函数
    - 基类的析构函数不是虚函数时
        1. 派生类的指针操作派生类，当析构这个派生类的指针的时候，先释放派生类资源，在释放基类资源
        2. 基类指针操作派生类，当析构这个基类指针的时候，只是放了基类的资源，而没有释放派生类的资源，造成了内存泄漏。
    - 基类的析构函数是虚函数时
        1. 基类指针操作派生类，当析构这个基类指针的时候，先释放派生类的资源，再调用基类的析构函数释放基类的资源
- 构造函数为什么一般不定义为虚函数
    - 如果父类的构造函数设置成虚函数，那么子类的构造函数会直接覆盖掉父类的构造函数。而父类的构造函数就失去了一些初始化的功能。
    - 虚函数的调用是需要通过“虚函数表”来进行的，而虚函数表也需要在对象实例化之后才能够进行调用。在构造对象的过程中，还没有为“虚函数表”分配内存。
    - 虚函数的调用是程序运行过程完成的，而对象的构造则是由编译器完成的
- 构造函数或者析构函数中调用虚函数会怎样
    - 基类的构造函数会首先被调用，基类构造函数中所调用的虚函数的实现版本是基类的。
- 虚函数与纯虚函数
    - 纯虚函数是一种特殊的虚函数，是被标明为不具体实现的虚函数
    - 纯虚函数是虚函数的一个子集，用于抽象类，含有纯虚函数的类就是抽象类，它不能生成对象。
- 静态关联和动态关联
    - 静态关联（对象调用）：指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起
    - 动态关联（地址实现）：指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数
    - 只有采用“指针->函数()”或“引用变量.函数()”的方式调用C++类中的虚函数才会执行动态绑定。
    - 对于C++中的非虚函数，因为其不具备动态绑定的特征，所以不管采用什么样的方式调用，都不会执行动态绑定。
- 深拷贝和浅拷贝
    - 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间
    - 深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。
    - 浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr
- C++中的几种构造函数
    - 默认构造函数：没有参数
    - 初始化构造函数：有参数和初始化列表
    - 拷贝构造函数：T(T& c)，应用场景
        1. 用一个已有的对象初始化一个新对象的时候
        2. 将一个对象以值传递的方式传给形参的时候
        3. 函数返回一个对象的时候
- gdb调试
    - run 运行程序
    - break n 在n行设置断点
    - clear n 清除第n行代码
    - delete n 清楚第n个断点
    - continue 继续运行到下一断点
    - next 单步跟踪程序
    - watch 表达式
    - print 表达式，任何C语言的有效表达式
- linux上进程有5种状态：ps -aux
    - 运行R
    - 中断S(休眠中, 受阻, 在等待某个条件的形成或接受到信号)
    - 不可中断D(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)
    - 僵死Z(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)
    - 停止T(进程收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号后停止运行运行)
- 模板的应用场景
    - 泛型编程
- C++类成员初始化为什么要首选初始化列表
    - 省去了临时对象的存在
    - 类中存在const成员，那么该成员必须在初始化列表中做初始化
    - 类中含有其它类B作为成员，而B类禁止掉赋值操作的情况下，那么对B的对象也只能通过初始化列表来实现
- C++的四种强制转换
    - static_cast：最常用的类型转换符，在正常状况下的类型转换，如把int转换为float，下行转换（基类---->派生类）由于没有动态类型检查，所以是不安全的
    - dynamic_cast: 在派生类之间转换时才使用，基类必须要有虚函数，对于下行转换，dynamic_cast是安全的
    - const_cast：用于去除const属性，把const类型的指针变为非const类型的指针
    - reinterpret_cas：重新解释，不到万不得已，不得使用这个转换符，高危操作
- 建立TCP服务器的各个系统调用
    - 客户端
        1. socket
        2. bind
        3. connect
        4. send
        5. receive
    - 服务器端
        1. socket
        2. bind
        3. listen
        4. accept
        5. receive
        6. send
- socket函数参数：抽象的socket对外提供了一个统一、方便的接口来进行网络通信
    - 协议族：ipv4，ipv6
    - 指定socket的类型：TCP类型，UDP类型
    - 指定具体的协议：TCP, UDP
- bind接口
    - 将创建的socket绑定到指定的IP地址和端口上，0成功，-1出错
- listen接口
    - listen()函数**仅被TCP类型的服务器**程序调用，实现监听服务，它实现2件事情
    - 函数listen()将套接口转换为被动式套接字
    - 第2个参数指定了内核为此套接字排队的最大连接个数
- connect接口
    - connect()通常由TCP类型客户端调用，用来与服务器建立一个TCP连接，实际是发起3次握手过程，连接成功返回0，连接失败返回1。 
- accept接口
    - accept()函数**仅被TCP类型的服务器程**序调用，从已完成连接队列返回下一个建立成功的连接，如果已完成连接队列为空，线程进入阻塞态睡眠状态。成功时返回套接字描述符，错误时返回-1。
- 路由协议
    - RIP(Bellman-Ford算法)：主要传递路由信息，每隔30秒广播一次路由表，最大跳数为15跳，用在网络架构较为简单的小型网络环境。
        1. 不同厂商的路由器可以通过RIP互联；
        2. 配置简单；适用于小型网络（小于15跳）
    - 开放式最短路径优先（Open Shortest Path First，OSPF)(迪杰斯特拉算法)
        1. OSPF能够在自己的链路状态数据库内表示整个网络
        2. OSPF支持路由验证
        3. OSPF是一个无类路由协议，路由信息不受跳数的限制
        4. OSPF支持VLSM和无类路由查表
    - BGP
        1. BGP用于连接Internet。BGPv4是一种外部的路由协议
- **TCP和UDP的区别** 
    - TCP面向连接; UDP是无连接的(速度UDP快)
    - TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复
    - TCP面向字节流; UDP是面向报文的
    - UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低
    - TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
- TCP端口
    - 端口号的范围是从1～65535
    - 其中1～1024是被RFC 3232规定好了的
    - 从1025～65535的端口被称为动态端口（Dynamic Ports），可用来建立与其它主机的会话
    - 常见端口
        1. TCP 20，21端口：FTP 文件传输服务
        2. TCP 25端口：SMTP 简单邮件传输服务
        3. UDP 53端口：DNS 域名解析服务
        4. TCP 80端口：HTTP 超文本传输服务
        5. TCP 443端口：HTTPS 加密的超文本传输服务
        6. TCP 23端口：TELNET 终端仿真服务（远程登陆）
- UDP端口
    - 161端口：SNMP 简单网络管理协议
    - 69端口：TFTP简单文件传输协议
- IP、TCP、UDP首部详解
    - IP首部
        1. 第一个4字节：版本号，首部长度，服务类型，总长度
        2. 第二个4字节：标识：用于标识IP数据报，片偏移
        3. 第三个4字节：生存时间，协议：1代表ICMP，2代表IGMP，6代表TCP，17代表UDP。校验和
        4. 第四个4字节：源IP地址
        5. 第五个4字节：目的IP地址
    - TCP首部
        1. 第一个4字节：端口号，目的端口
        2. 第二个4字节：序号：TCP连接中传送的字节流中的每个字节都按顺序编号
        3. 第三个4字节：确认号：期望收到对方下一个报文的第一个数据字节的序号
        4. 第四个4字节：数据偏移，6个标志位，紧急URG，确认ACK，推送PSH，复位RST，同步SYN，终止FIN
        5. 第五个4字节：检验和，紧急指针
    - UDP首部
        1. 伪首部（12字节）：源IP地址，目的IP地址，协议（17），UDP长度
        2. 首部（8字节）：源端口号，目的端口号，长度，检验和
- **网页解析的全过程(输入url到展示页面)**
    - DNS解析
        1. 浏览器首先搜索浏览器自身缓存的DNS记录
        2. 搜索hosts文件和操作系统缓存
        3. 域名解析服务器发送解析请求
        4. 开始递归+迭代解析：为什么是递归：问题由一开始的本机要解析mail.google.com变成域名解析服务器要解析mail.google.com，这是递归。
           为什么是迭代：问题由向根域服务器发出请求变成向com域服务器发出请求再变成向google.com域发出请求，这是迭代。
    - 建立TCP连接
    - 浏览器向 web 服务器发送一个 HTTP 请求
    - 发送响应数据给客户端：Web服务器根据HTTP请求头的信息，得到响应数据返回给客户端
    - 浏览器解析http response
        1. html文档解析
        2. 浏览器发送获取嵌入在HTML中的对象：加载过程中遇到外部css文件
        3. css解析
        4. js解析
- TCP的三次握手
    - 最开始客户端和服务器都是处于**CLOSED状态**，主动打开连接的为客户端，被动打开连接的是服务器。
    - TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了**LISTEN（监听）状态**
    - 1.TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 **SYN-SENT（同步已发送状态）状态**。
    - 2.TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了**SYN-RCVD（同步收到）状态**。
    - 3.TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入**ESTABLISHED（已建立连接）状态**。
    - 服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了
- TCP的四次挥手
    - 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入**FIN-WAIT-1（终止等待1）状态**
    - 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了**CLOSE-WAIT（关闭等待）状态**
    - 客户端收到服务器的确认请求后，此时，客户端就进入**FIN-WAIT-2（终止等待2）状态**，等待服务器发送连接释放报文
    - 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，**服务器就进入了LAST-ACK（最后确认）状态**，等待客户端的确认
    - 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
    - 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。
- TCP为什么要三次握手，而不能二次握手
    - client发出的第一个连接请求报文段(SYN)并没有丢失，而是在某个网络结点长时间的滞留了。
    - server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接
    - 两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。
    - 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。
- 为什么客户端最后还要等待2MSL
    - 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失
    - 如果丢失ACK报文，服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
- TCP怎么保证可靠性
    - 应用数据被分割成TCP认为最适合发送的数据块。
    - 超时重发：启动一个定时器。等待目的端确认收到这个报文段
    - 校验：当TCP收到发自TCP连接另一端数据，它将发送一个确认。这个确认不是立即发送，通常推迟几分之一秒用来对包的完整性进行校验
    - 滑动窗口
    - 拥塞控制
- TCP滑动窗口协议
    - 窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”
    - “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”
    - 已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据
    - 在收到确认信息之后窗口才向后滑动
- TCP拥塞控制
    - 一般原理：发生拥塞控制的原因：资源(带宽、交换节点的缓存、处理机)的需求>可用资源。
    - 拥塞窗口：发送方为一个动态变化的窗口叫做拥塞窗口
    - 慢启动算法：主机刚开始发送数据报的时候先探测一下网络的状况
    - 拥塞避免：是让cwnd缓慢的增加而不是加倍的增长，每经历过一次往返时间就使cwnd增加1，而不是加倍，这样使cwnd缓慢的增长，比慢启动要慢的多。
    - 快重传：要求首先接收方收到一个失序的报文段后就立刻发出重复确认
    - 快恢复：当发送方一连接收到三个重复确认后就立即重传。而不是等到重传计时器到期
- GET与POST方法有以下区别
    - 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交
    - GET方式提交的数据最多只能有1024字节，而POST则没有此限制。
    - 安全性问题。正如在（1）中提到，使用 Get的时候，参数会显示在地址栏上，而 Post不会
- HTTP状态码
    - 200 - 请求成功
    - 301 - 资源（网页等）被永久转移到其它URL
    - 404 - 请求的资源（网页等）不存在
    - 500 - 内部服务器错误
    - 1** - 信息，服务器收到请求，需要请求者继续执行操作
- HTTPS和HTTP的区别
    - https协议需要到CA申请证书，一般免费证书很少，需要交费。
    - http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议
    - http和https使用的是完全不同的连接方式用的端口也不一样，前者是80，后者是443
    - http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
- URL，即Uniform Resource Locators，是指统一资源定位器，由协议、域名、路径及文件名三部分组成
- 对称密钥与非对称密钥
    - 对称密钥加密，又称私钥加密，即信息的发送方和接收方用一个密钥去加密和解密数据。它的最大优势是加/解密速度快
    - 非对称密钥加密系统，又称公钥密钥加密。它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人
- 快排的优化
    - 最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列
    - 三数取中选择枢轴+插排+聚集相等元素
    - 快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化
    - 使用并行或多线程处理子序列
- innodb和myisam的特点与区别
    - 存储空间：MyISAM：可被压缩，存储空间较小。InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
    - 事务支持：MyISAM：强调的是性能，不支持事务。InnoDB：提供事务支持事务，外部键等高级数据库功能。
    - 表锁差异：MyISAM：只支持表级锁。InnoDB：支持事务和行级锁，是innodb的最大特色。
    - MyISAM：支持 FULLTEXT类型的全文索引，而InnoDB不支持。
    - MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。
    - InnoDB：支持外键。MyISAM：不支持
- MySQL事务（4个条件）：MySQL 事务主要用于处理操作量大，复杂度高的数据
    - 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成
    - 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏
    - 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力
    - 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
- 并发事务可能引起的事情
    - 脏读：对于两个事务T1和T2，T1读取了已经被T2更新但还没有被提交的字段。之后，若T2进行回滚，T1读取的内容就是临时且无效的
    - 丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，导致第一个事务更新的数据丢失，这是由于没有加锁造成的
    - 不可重复读：在同一事务中，两次读取同一数据，得到内容不同，也就是有其他事务更改了这些数据
    - 幻读：一个事务在执行过程中读取到了另一个事务已提交的插入数据
- 索引的好处和缺点
    - 大大加快数据的检索速度
    - 创建唯一性索引，保证数据库表中每一行数据的唯一性
    - 加速表和表之间的连接；
    - 索引需要占用数据表以外的物理存储空间
    - 创建索引和维护索引要花费一定的时间
    - 当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。
- 索引类型：
    - 唯一索引：UNIQUE每一个索引值只对应唯一的数据记录
    - 主键索引：主键索引是唯一索引的特定类型
    - 聚集索引：表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引
    - 全文索引：它能够利用“分词技术”等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果，全文索引只能用于数据库引擎为MyISAM的数据表，MySQL自带的全文索引只能对英文进行全文检索
- 贪心算法和动态规划的区别
    - 贪心算法选择过程中仅需确定当前元素是否要选取，与后面的元素是什么没有关系。
    - 动态规划的选择策略是试探性的，每一步要试探所有的可行解并将结果保存起来，最后通过回溯的方法确定最优解
- STL容器的底层实现
    - vector: 线性连续空间，支持的动态增加大小，以原大小的两倍另外配置一块较大空间，然后将原空间内容拷贝过来，再开始在原内容之后构造新元素，并释放原空间
    - list：环状双向链表
    - **deque**：deque采用一块所谓的map（不是STL的map容器）作为主控，deque是由一段一段的定量连续空间构造。一旦有必要在deque的前端或尾端增加新空间，便配置一段连续空间，串接在整个deque的头部或尾部
- 
    