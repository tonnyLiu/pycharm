# 零碎的知识点
- 当class内至少含有一个virtual函数，才能将它声明为virtual析构函数
- 当class中有虚函数，会有一个vptr（virtual table pointer）指针，来在运行时决定
哪一个虚函数该被调用，占用一个指针的大小
- 纯虚函数是虚函数的一个子集，用于抽象类，含有纯虚函数的类就是抽象类，它不能生成对象
- static关键字总结
    - 隐藏：可以在不同的文件中定义同名函数和同名变量
    - 保持变量的内容的持久：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围。
    如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。
    - 默认初始化为0：在静态数据区，内存中所有的字节默认值都是0x00
    - 类成员声明为static：静态数据成员是类的成员，而不是对象的成员
        1. 类的静态成员函数**仅能访问类的静态数据和静态成员函数** 
        2. 不能将静态成员函数定义为虚函数
        3. 类的静态成员初始化**在类体外进行**，而前面不加static
        4. 为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响
- 内存分区
    - 堆区：由编程人员手动申请，手动释放。使用malloc或者new进行堆的申请，堆的总大小为机器的虚拟内存的大小。
    - 栈区：由系统进行内存的管理。主要存放**函数的参数以及局部变量**。在函数完成执行，系统自行释放栈区内存，不需要用户管理。
    - 全局/静态存储区：全局/静态存储区内的变量在程序编译阶段**已经分配好内存空间并初始化**。分为全局初始化区和BSS区（全局未初始化区）。
    这块内存在程序的整个运行期间都存在，它主要存放**静态变量、全局变量**。
    - 文字常量区：常量字符串存放在这里
    - 代码区：存放程序编译后的二进制代码，不可寻址区。
- new和malloc的区别
    - new先底层调用malloc分了配内存，然后创建一个对象（调用构造函数），delete先调用析构函数（清理资源），然后底层调用free释放空间
    - malloc是C语言中的**库函数**，而new是C++中的**操作符**。
    - malloc申请之后返回的类型是void*，而new返回的指针带有类型。
    - malloc只负责内存的分配而不会调用类的构造函数，而new不仅会分配内存，而且会自动调用类的构造函数，并且可以自动计算所需要大小。
- 堆区和栈区的区别：
    - 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制
    - 空间大小：默认的栈空间大小是1M，32位堆内存可以达到4G的空间
    - 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列
    - 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
    - 生长方式和效率
- const的作用
    - 定义常量
    - 便于类型检查
    - 保护防止修改
    - 方便进行参数调整和修改
    - 节约空间
- const的使用
    - 定义常量必须初始化（修饰变量）
    - 顶层和底层const（修饰指针引用）
    - const修饰函数参数：参数为引用，可以增加效率同时防止更改。按值传递会先建立一个类对象的副本，而传地址更有效。
    - const修饰函数返回值，多同于操作符重载。
    - 类相关const：
        1. const修饰成员变量，只能在初始化列表中赋值
        2. 修饰成员函数，被const类对象，指针，引用调用。
        3. const可以防止对成员函数的修改，也可以被非const对象调用
- 采用const_cast把const转化为非const。
- 正则表达式 regexp(后面跟着字符串)：
    - .(点)：匹配任意字符；
    - |(or)：两者之一；
    - []:[2345]56表示256，356，456，556其中一种，^表示否定[^123]；
    - 匹配范围：[1-5],[a-f];
    - 特殊字符：使用转义(\\)
    - 匹配多个实例
        1. *：0个或多个匹配；
        2. +：1个或多个匹配{1,}；
        3. ?：0个或一个匹配{0,1}；
        4. {n}：指定数量的匹配；
        5. {n,}：不少于指定数量的匹配；
        6. {n,m}：范围匹配(m不超过255)。
    - 定位符
        1. 
- Linux文件三个时间：
    - mtime：修改时间
    - ctime：状态时间，更改了权限和属性，就会更新时间
    - atime：访问时间
- 枚举变量的默认值是前一个变量加1，而第一个没有被赋值，其默认值是0。
- float，bool，int，指针变量与“零值”的比较
    - bool：if(!n)
    - int：if(n == 0)
    - float：**const float ep = 0.0000001;  if((x >= -ep)&&(x <= ep))**
    - 指针：if(p == NULL)
- 字节对齐：便于cpu快速访问，合理利用字节对齐可以节省空间。
- 指针和引用的区别
    - 指针是一个变量（对象），引用是变量的别名
    - 引用必须初始化且不能更改，指针可以为空，并且可以更改
    - 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 
    用的修改都会改变引用所指向的对象
    - 可以有const指针，但是没有const引用
    - 指针和引用的自增（++）运算意义不一样
    - 指针可以有多级，引用只能有一级
- 值传递和引用传递
    - 值传递过程中，被调函数的形参作为被调函数的局部变量来处理，成为实参的一个副本，被调函数的任何操作都是
    作为局部变量进行，不会影响实参变量的值、
    - 引用传递是传递实参变量的地址，因此被调函数对形参的任何参作都被处理成间接寻址。
- 指针和数组
    - 修改内容不同：char a[] = "hello";可以通过取下标的方式对元素值进行修改。
    char *p = "hello";p指向常量字符串，不可以改变其中的值
    - sizeof不同
- 指针与数字相加，主要是计算偏移量，大小=数字*sizeof(指针指向的类型)
- sizeof和strlen的区别
    - sizeof是**关键字**，也是**运算符**。strlen是函数
    - sizeof返回结果是size_t
    - sizeof是在编译时计算的，可以用来定义数组的维度。
- 野指针和空指针
    - 野指针是指向不可用内存的指针。指针在创建时，其值是随机的，指针在free和delete后，也会导致野指针
    - 空指针：可以指向任何其他类型的指针。C++11中用nullptr来定义空指针
- <>and""的区别
    - <>编译器先从标准库的路径搜索，使用系统文件调用较快。
    - ""是从用户的工作目录开始搜索，然后去寻找系统路径，使自定义文件较快。
- #define有什么缺陷
    - 无法进行类型检查
    - 由于优先级不同，可能存在副作用
    - 无法操作类的私有成员
- typedef和define的区别
    - 原理不同：define是预处理指令，不做类型检查；typedef是关键字，在自己的作用域给一个已经存在的类型起别名
    - 功能不同：typedef不止包括内部类型，还有自定义类型struct。
    - define没有作用域限制
    - define只是简单的字符串的替换，而typedef是类型别名带有实际意义
- const和define的区别
    - define预处理阶段进行替换，const是在编译阶段进行类型检查
    - define不分配内存，在内存中有多个拷贝，消耗内存大；const在静态区分配内存，只有一个拷贝
    - define没有类型检查，const有
- struct和union区别
    - 联合体所有成员共用一块地址空间，长度等于最长成员的长度；结构体占用空间是累加的
    - 对于联合体不同成员赋值，将会对其他成员重写；结构体没有影响
- C和C++区别
    - c面向过程，c++面向对象
    - 动态内存的管理方式不一样
    - c和c++中的struct不同
        1. c的struct不能有函数成员，c++可以
        2. c的struct没有权限的限定
        3. c的struct不能继承
    - c不支持函数的重载
    - c++有引用，c没有
    - 输入输出流不同
- c++中struct和class区别
    - 默认的继承访问权限。struct是public的，class是private的
- 公有，私有，保护继承
    - 基类中私有成员private在派生类三个继承均不可访问
    - 公有：public->public,protected->protected
    - 私有：public->private,protected->private
    - 保护：public->protected,protected->protected
- 2乘以8的最有效的方法
    - 2<<3:左移表示乘法
    - (x<<3)-1:x的7倍
- **select，poll，epoll之间区别**
    - select:
- 进程与线程的区别
    - 进程是系统进行分配资源和调度的独立单位。是资源分配的基本单位
    - 线程是进程的实体，是CPU调度和分配的基本单位
    - 一个线程只能属于一个进程，一个进程可以包含多个线程
    - 属于一个进程的所有线程共享资源，进程间相互独立，有各自的内存空间
    - 进程是程序的一次执行，线程是一段程序片段的执行
- 一个进程可以创建多少线程，和什么有关
    - 主要由用户可用的内存空间和栈的大小来决定，比如x86平台32位系统，寻址空间为4GB(2^32-1),用户可以使用的
    大小大约为2GB，每个栈的大小默认为1MB，大约可以创建2000个进程
- 一个程序从开始运行到结束的完整过程
    - 预处理阶段
        1. 宏定义指令
        2. 条件编译指令
        3. 头文件包含指令
    - 编译阶段：把预编译的文件进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件
    - 汇编阶段：主要的作用是汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程
    - 链接阶段：链接程序的主要工作就是将有关的目标文件彼此相连接。
- 进程间通信方式总结（windows 和linux）
    - windows：
         1. 文件映射
         2. 共享内存
         3. 匿名管道（父子进程）
         4. 命名管道（不相关的进程）
         5. 邮件槽
         6. 剪切板
         7. 动态数据交换
         8. sockets
    - linux：
         1. 管道
         2. 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。
         3. 共享内存：由一个进程创建，但多个进程都可以访问。
         4. 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
         5. 套接字sockets：它可用于不同及其间的进程通信
         6. 信号： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生  
- 线程间通信方式
    - 互斥量
    - 临界区
    - 信号量
    - 事件
- 进程调度
    - 先进先出
    - 最短CPU运行期优先调度算法
    - 时间片轮换法
    - 多级反馈队列
- OSI的7层模型
    - 物理层
    - 数据链路层：
    - 网络层：路径选择、路由及逻辑寻址
    - 传输层：将上层数据分段并提供端到端的、可靠的或不可靠的传输
    - 会话层：负责建立、管理、终止进程之间的会话
    - 表示层：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解
    - 应用层：为操作系统或网络应用程序提供访问网络服务的接口
- linux命令
    - df查看磁盘空间大小
    - top任务管理器
    - ps查看进程
- C++与java的区别
    - java运行在JVM上。可移植性强
    - java取消指针，完全面向对象
    - Java编写效率高，但运行速度慢
    - 垃圾回收机制不同，java自动回收，c++析构函数
    - java在web应用强于c++，c++桌面应用强于java
- STL中的内存分配器:allocator:第一级小于128byte
    - 通过组织16个空闲列表，对小对象的分配做了优化
    - 小对象的快速分配和释放
    - 避免内存碎片的产生。零乱的内存碎片不仅会浪费内存空间
- hash表构造函数方法
    - 除法散列法：h(k) = k % p;
    - 平方散列法：
    - 斐波那契散列法：
- hash处理冲突的方法
    - 再散列法：Hi = (H(key) + di) % m
        1. 线性探测再散列
        2. 二次探测再散列 di = 1^2, -1^2, 2^2...
        3. 伪随机探测再散列
    - 再哈希法：同时构造多个哈希函数
    - 拉链法(链地址法)：将所有哈希地址为i的元素构成一个称为同义词链的单链表
- 海量数据
    - 海量日志数据：
        1. IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理
        2. 按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中
        3. 对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map
        4. 可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP
    - 搜索引擎记录top10
        1. 先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计
        2. 借助堆这个数据结构，找出Top K，时间复杂度为N*logK
- 红黑树的特征：红黑树，插入，删除，查找的复杂度都是O（log N）
    - 节点是红色或黑色。
    - 根节点是黑色
    - 每个叶节点是黑色的
    - 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
    - 从**任一节点到其每个叶子的**所有路径都包含相同数目的黑色节点
- AVL树：插入操作LL、LR、RR、RL
    - 左子树和右子树都是AVL树
    - 左子树和右子树的高度差不能超过1
- 红黑树应用
    - map和set都是用红黑树实现的
    - 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块
    - epoll在内核中的实现，用红黑树管理事件块
- STL中hash_map和map的区别
    - map
        1. 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。
        2. 红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现
        3. 适用处：对于那些有顺序要求的问题，用map会更高效一些
    - hash_map
        1. 因为内部实现了哈希表，因此其查找速度非常的快
        2. 缺点： 哈希表的建立比较耗费时间, 内存占的比较大
        3. 对于查找问题，unordered_map会更加高效一些
- STL vector的内部实现原理及基本用法
    - 一个动态增长的数组，里面有一个指针指向一片连续的内存空间，当空间装不下的时候会自动申请一片更大的空间。
    - reserve（Count） 函数主要是预留Count大小的空间，对应的是容器的容量，只有当空间不足时，才会操作，即重新分配一块内存，将原有元素拷贝到新内存，并销毁原有内存
    - resize（Count） 函数主要是用于改变size的，也就是改变vector的大小，最终改变的是（_Mylast - _Myfirst）的值，当size < Count时,就插入元素，当size >Count时，就擦除元素。
- fork函数
    - 计算机程序设计中的分叉函数。返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程标记；否则，出错返回-1。
    - 当调用fork()函数时，在该位置进程一分为二，一个是父进程，一个是子进程。
- vector注意事项
    - vector迭代器失效：使用者在一个较小索引位置上安插或移除元素。由于容量变化而引起重新分配。
- 重写与重载的区别
    - 方法的重写是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系
    - 重写要求参数列表相同；重载要求参数列表不同
    - 重写关系中，调用那个方法体，是根据**对象的类型**来决定；重载关系，是根据调用时的**实参表与形参表来**选择方法体的。
- 虚函数实现原理
    - 通过一张虚函数表来实现的
    - 通过虚函数指针指向虚函数表
    - 一般继承（无虚函数覆盖）
        1. 虚函数按照其声明顺序放于表中
        2. 父类的虚函数在子类的虚函数前面
    - 一般继承（有虚函数覆盖）
        1. 覆盖的函数被放到了虚表中原来父类虚函数的位置
        2. 没有被覆盖的函数依旧
- 析构函数为什么要写成虚函数
    - 基类的析构函数不是虚函数时
        1. 派生类的指针操作派生类，当析构这个派生类的指针的时候，先释放派生类资源，在释放基类资源
        2. 基类指针操作派生类，当析构这个基类指针的时候，只是放了基类的资源，而没有释放派生类的资源，造成了内存泄漏。
    - 基类的析构函数是虚函数时
        1. 基类指针操作派生类，当析构这个基类指针的时候，先释放派生类的资源，再调用基类的析构函数释放基类的资源
- 构造函数为什么一般不定义为虚函数
    - 如果父类的构造函数设置成虚函数，那么子类的构造函数会直接覆盖掉父类的构造函数。而父类的构造函数就失去了一些初始化的功能。
    - 虚函数的调用是需要通过“虚函数表”来进行的，而虚函数表也需要在对象实例化之后才能够进行调用。在构造对象的过程中，还没有为“虚函数表”分配内存。
    - 虚函数的调用是程序运行过程完成的，而对象的构造则是由编译器完成的
- 构造函数或者析构函数中调用虚函数会怎样
    - 基类的构造函数会首先被调用，基类构造函数中所调用的虚函数的实现版本是基类的。
- 虚函数与纯虚函数
    - 纯虚函数是一种特殊的虚函数，是被标明为不具体实现的虚函数
    - 纯虚函数是虚函数的一个子集，用于抽象类，含有纯虚函数的类就是抽象类，它不能生成对象。
- 静态关联和动态关联
    - 静态关联（对象调用）：指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起
    - 动态关联（地址实现）：指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数
    - 只有采用“指针->函数()”或“引用变量.函数()”的方式调用C++类中的虚函数才会执行动态绑定。
    - 对于C++中的非虚函数，因为其不具备动态绑定的特征，所以不管采用什么样的方式调用，都不会执行动态绑定。
- 深拷贝和浅拷贝
    - 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间
    - 深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。
    - 浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr
- C++中的几种构造函数
    - 默认构造函数：没有参数
    - 初始化构造函数：有参数和初始化列表
    - 拷贝构造函数：T(T& c)，应用场景
        1. 用一个已有的对象初始化一个新对象的时候
        2. 将一个对象以值传递的方式传给形参的时候
        3. 函数返回一个对象的时候
- gdb调试
    - run 运行程序
    - break n 在n行设置断点
    - clear n 清除第n行代码
    - delete n 清楚第n个断点
    - continue 继续运行到下一断点
    - next 单步跟踪程序
    - watch 表达式
    - print 表达式，任何C语言的有效表达式
- linux上进程有5种状态：ps -aux
    - 运行R
    - 中断S(休眠中, 受阻, 在等待某个条件的形成或接受到信号)
    - 不可中断D(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)
    - 僵死Z(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)
    - 停止T(进程收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号后停止运行运行)
- 模板的应用场景
    - 泛型编程
- C++类成员初始化为什么要首选初始化列表
    - 省去了临时对象的存在
    - 类中存在const成员，那么该成员必须在初始化列表中做初始化
    - 类中含有其它类B作为成员，而B类禁止掉赋值操作的情况下，那么对B的对象也只能通过初始化列表来实现
- C++的四种强制转换
    - 