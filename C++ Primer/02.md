# 1. 变量和基本类型
- 数据类型是程序的基础，它告诉我们数据的意义以及我们能在数据上的操作。

## 1.1 基本内置类型
- 两类：算术类型和空类型  
- 空类型仅用于特殊场合，当函数不返回任何值时用空类型作为返回类型。

### 1.1.1 算术类型
- 两大类：整形和浮点型
    - 整形：char，int，long
        - 计算机可寻址的最小内存块称为“字节(byte)”,字节由8比特构成。存储的基本单元称为“字(word)”,
        通常为4或8个字节组成。
        - 一个char的大小和一个机器字节是一样的。
        - unsigned char可以表示为0到255，signed char可表示-128到127。
    - 浮点型：float和double
        - float 大小为一个字(32比特)，double 大小为2个字。
    - 类型转换
        - 浮点数赋值整数，仅保留浮点数中小数点之前的部分。
        - **无符号**类型超出范围：0-255的unsigned char 赋值-1，得到的是255(256+(-1))。
        - **有符号**类型超出范围，结果是**未定义的**。
        - 无符号数与int运算时，会使int强制转换为无符号数。因此不要混用带符号和无符号类型。
        
### 1.1.2 字符和字符串
- 单引号括起来的一个字符称为char型，'a'。
- 字符串使由常量字符构成的数组，字符串结尾处会有空字符('\0')，因此字符串的实际长度比内容多1。"Hello"。

## 1.2 变量
- 变量具有数据类型，数据类型决定变量的所占内存的大小和布局方式，储存值的范围以及变量可以参与的运算。

### 1.2.1 变量定义
- 类型说明符：int...
- 初始值 ：初始化变量
    - = 是赋值操作符，**初始化不是赋值，初始化是创建变量是赋予一个初始值，而赋值是把对象的当前值擦除，而
    以一个新值代替。**
    - **_C++ 11用花括号来初始化变量，称为列表初始化。_**
    - 默认初始化：定义与任何函数体之外的变量被初始化为0。**函数体内部的内置类型变量不被初始化。**
    建议初始化每一个内置类型的变量。
    
### 1.2.2 变量声明与定义的关系
- [参考博客](https://blog.csdn.net/gatieme/article/details/50640424)
- C++支持分离式编译，声明使名字为程序所知，而定义负责创建于名字关联的实体。定义分配存储空间，而声明不会。
- 变量定义只能有一次，但可以多次声明。
- 函数的定义是有花括号的，函数在定义前要声明否则会出错。
- 使用extern声明变量而非定义，并且不要显示初始化，在函数体内部，不可以初始化extern变量。

### 1.2.3 变量的命名规范
- 标识符由数字，字母和下划线组成，不得以数字开头
- 标识符要体现实际含义
- 变量首字母小写，推荐使用小驼峰
- 类名使用大驼峰
- 也可以使用下划线把多个单词分隔开

## 1.3复合类型
- 基于其他类型定义的类型：引用和指针

### 1.3.1 引用    
- 引用就是为对象起别名，必须初始化，初始值必须是一个对象且类型相同
```markdown
    int a = 1;
    int &a1 = a;
```

### 1.3.2 指针   
- 指针与引用的不同
    - 指针本身是一个对象，引用并非是一个对象，允许对指针赋值和拷贝，可以指向
    几个对象
    - 指针不需要定义时赋初值，但建议初始化所有指针
- 获取对象的地址
```markdown
    double dval;
    double *pd = &dval;    //取地址符&
    double *pd1 = pd;
```
- 空指针
    - 不指向任何对象
    `int *p1 = nullptr;`
    - **C++ 11 中推荐使用nullptr 来初始化指针，避免使用NULL**
    
### 1.3.3 复合类型
    int *p1, p2;      //要将类型修饰符*和变量一起写
- p1是指向int的指针，p2是一个int变量。基本数据类型是int。
- 指向指针的引用
    - 指针是一个对象，可以存在引用。
 ```markdown
    int *p;
    int *&r = p;
```
    - 从右向左读r的定义，离r最近的是&，所以r是一个引用。接下来是*，说明r
    引用的是一个指针。最后，基本数据类型说明r引用的是一个int指针。

## 1.4 const限定符
- **const对象不可以被更改，必须初始化。**

### 1.4.1 const的引用
    const int ci = 1024;
    const int &r = ci;       //正确，引用的是const，前面必须加const
    int &r1 = ci;            //错误，没有加const
- 初始化常量引用时，可以用任意表达式作为初始值。

### 1.4.2 const和指针
    const int a = 3;
    const int *p = &a;
- const指针
    - const指针是指指针本身是一个常量，且必须初始化。
```markdown
      int e1 = 0;
      int *const p1 = &e1;            //p1将一直指向e1
      const double e2 = 3.14;
      const double *const p2 = &e2;   //p2是指向常量的常量指针  
```
   - 常量指针是指指针本身不可变，不是所指向的值不可变，这要看指向的值是不是可变的，例如：   
```markdown
    *p1 = 3;           //正确，e1是可变的
    *p2 = 4.12;        //错误，e2是个常量
```

### 1.4.3 顶层const
- 顶层const表示任意的对象是常量，底层const表示指向的对象是一个常量。指针可以是顶层const也可以是
底层const，用于声明的引用的const都是底层const。
```markdown
    int i = 0;
    int *const p1 = &i;           //顶层const
    const int ci = 42;            //顶层const
    const int *p2 = &ci;          //底层const
    const int *const p3 = p2;     //左边是底层const，右边是顶层const
```

## 1.5 处理类型

### 1.5.1 auto类型说明符
- **C++ 11 中引入auto。让编译器通过初始值来推算变量的类型。因此必须有初始值。**
- auto一般会忽略顶层const，底层const会保留。

### 1.5.2 decltype类型指示符
- 作用是选择并返回操作数的数据类型
```markdown
    const int ci = 0, &cj = ci;
    decltype(ci) x = 0;            //x是const int
    decltype(cj) y = x;            //y是const int&
```


